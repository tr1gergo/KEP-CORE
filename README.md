# Kidney Exchange Core Analyses

This repository contains the experimental framework used to evaluate core-stable kidney exchange allocations across multiple notions of stability (TU core, strong core, weak core, and a lexicographically optimised weak-core heuristic). The codebase builds on the XML instances generated by the accompanying simulator and provides tools to explore, visualise, and benchmark the algorithms.

## Repository Layout

- `KEP_functions.py` - main library implementing:
  - compatibility graph construction and cycle enumeration;
  - core verification, strong/weak-core heuristics with cut generation;
  - TU-core formulation with altruist pre-allocation;
  - lexicographic weak-core optimisation with blood-type and hardness features;
  - plotting helpers and solver utilities (PuLP, GUROBI/CBC backends).
- `instance_analysis.py` - parsers and summary helpers for XML instances (donor/recipient metadata, altruist detection).
- `explore_instances.ipynb` - exploratory data analysis of the raw instances (distributions, altruist counts, etc.).
- `core_workflow_demo.ipynb` - end-to-end sanity checks: graph build, cycle visualisation, core verification, lexicographic solver smoke test.
- `paper_simulations.ipynb` - production-grade simulation sweep for the paper: iterates over player grids, cohort sizes, cycle caps, and algorithms; writes results and figures to `figures/`.
- `instances/`, `instances_large/` - source XML files (small and large cohorts respectively).
- `figures/` - autogenerated plots (line plots vs players, heatmaps, and CSV summaries).
- `kidney_core.pdf` - manuscript draft (for reference).

## Simulation Workflow

1. **Environment:** Python 3.10+, PuLP, NumPy, pandas, matplotlib. GUROBI is supported (if licensed) but CBC is used by default.
2. **Data prep:** XML instances live under `instances/` (small) and `instances_large/` (paper-scale). `instance_analysis.py` extracts donor/recipient meta features, including altruist adjacency lists.
3. **Algorithms:** Implemented in `KEP_functions.py`:
   - `core_heuristic` (weak core), `strong_core_heuristic` (strong core) - cut-adding heuristics that extend the base maximum cycle packing, adding altruists only when IPs become infeasible.
   - `core_tu_simple` - TU-core IP with limited altruist augmentation (capped at 5% of vertices), coalition constraints, and lexicographic penalty on altruist edges.
   - `lexicographic_core_search` - four-tier optimisation (max transplants -> max cycles -> max blood-type matches -> maximise hard-to-match vertices) with weak-core verification.
4. **Paper experiments:** Execute `paper_simulations.ipynb`. It:
   - loops across player counts `[5, 10, 15, 20, 30, 50]`, cohort sizes `[100, 200, 400, max]`, and cycle caps (`Delta=2,3`);
   - runs TU, strong, weak, and lexicographic algorithms, reusing early "zero altruist'' results to skip redundant computations;
   - aggregates outcomes in `figures/paper_simulations_results.csv`, builds summary tables, and renders PNG plots under `figures/`.

## Reproduction Steps

1. Install dependencies (PuLP, NumPy, pandas, matplotlib, networkx). Add GUROBI if available.
2. Ensure XML instances reside in `instances/` and `instances_large/`.
3. Open `paper_simulations.ipynb` and run all cells. Results and plots will appear under `figures/`.
4. For interactive diagnostics or debugging, use `core_workflow_demo.ipynb` and `explore_instances.ipynb`.

## Notes

- All random sampling uses `numpy.random.Generator` seeds for reproducibility.
- Cycle enumeration respects the global `Delta in {2,3}` cap throughout heuristics and IPs.
- Strong -> weak -> lexicographic shortcuts are encoded in the simulation helper to minimise redundant runs.
- Altruist addition reflects XML data: real altruist edges are injected first; synthetic altruists are only used as a fallback.

Feel free to adapt the notebooks or extend `KEP_functions.py` for additional heuristics or visualisations.
